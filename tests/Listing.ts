import { expect } from "chai";
import { ethers } from "hardhat";

// Utils
import Wallet from "./helpers/Wallet";
import { taxationPeriodToSeconds } from "./helpers/utils";
import { snapshotEVM, revertEVM } from "./helpers/EVM";

// Constants
import { ETH0, ETH1, ETH2, ETH3, GLOBAL_TRX_CONFIG } from "./helpers/constants";

// Types
import {
  TOKENS,
  ERC721ErrorMessages,
  ERC721MetadataErrorMessages,
} from "./helpers/types";
import {
  ErrorMessages as PCOErrorMessages,
  Events as PCOEvents,
  RemittanceTriggers,
} from "./PartialCommonOwnership/types";
import type { Contract } from "@ethersproject/contracts";
import type { Web3Provider } from "@ethersproject/providers";
import type { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import type { BigNumber } from "ethers";

//$ Local Types

enum ErrorMessages {
  ORIGINATOR_ONLY = "Wrap originator only",
  DEPOSIT_REQUIRED = "Deposit required",
  NO_DEPOSIT_REQUIRED = "No deposit required",
  VALUATION_GREATER_THAN_ZERO = "Valuation must be > 0",
  ADDRESS_ZERO = "Beneficiary cannot be address zero",
  BAD_TAX_RATE = "Tax rate must be > 0",
  BAD_COLLECTION_FREQUENCY = "Tax frequency must be > 0",
}

enum Events {
  // TODO
}

//$ Constants

const wrapValuation = ETH1;

const mintedTestNFTs = [TOKENS.ONE, TOKENS.TWO, TOKENS.THREE];

const taxConfig = { collectionFrequency: 365, taxRate: 50000000000 };

//$ State
let provider: Web3Provider;
let signers: Array<SignerWithAddress>;
let NFTContract: Contract;
let feeContract: Contract;
let wrapperContract: Contract;
let ERC20Contract: Contract;
let zoraModuleManagerContract: Contract;
let ERC20TransferHelperContract: Contract;
let ERC721TransferHelperContract: Contract;
let protocolFeeSettingsContract: Contract;
let royaltyEngineContract: Contract;
let royaltyRegistryContract: Contract;
let asksV1_1Contract: Contract;
let deployer: Wallet;
let deployerNFT: Wallet;
let deployerFee: Wallet;
let bob: Wallet;
let alice: Wallet;
let registrar: Wallet;
let snapshot: any;
let wallets: Array<Wallet>;
let walletsByAddress: {
  [address: string]: Wallet;
};

//$ Helpers

/**
 * Approves a token for wrapping and successfully wraps it.
 * @param tokenId Token to wrap
 * @returns Transaction data
 */
async function wrap(tokenId: TOKENS, beneficiary: Wallet): Promise<BigNumber> {
  await deployerNFT.contract.approve(wrapperContract.address, tokenId);

  // If wrapper is beneficiary, no deposit is necessary; otherwise, it's required.
  const deposit = beneficiary.address == deployer.address ? ETH0 : ETH3;

  const trx = await deployer.contract.wrap(
    NFTContract.address,
    tokenId,
    wrapValuation,
    beneficiary.address,
    taxConfig.taxRate,
    taxConfig.collectionFrequency,
    { value: deposit }
  );

  const id = wrappedTokenId(NFTContract.address, tokenId);

  return id;
}

/**
 * Generates the token ID for a wrapper NFT.
 * IDs are generated by taking hash(contract, tokenId).
 * @param contractAddress NFT Contract Address
 * @param tokenId NFT token id
 * @returns ID string
 */
function wrappedTokenId(contractAddress: string, tokenId: TOKENS): BigNumber {
  return ethers.BigNumber.from(
    ethers.utils.keccak256(
      ethers.utils.defaultAbiCoder.encode(
        ["address", "uint"],
        [contractAddress, tokenId]
      )
    )
  );
}

//$ Tests

describe("Listing.sol", async function () {
  before(async function () {
    //@ts-ignore
    provider = new ethers.providers.Web3Provider(web3.currentProvider);
    signers = await ethers.getSigners();

    // Deploy the test ERC20 contract
    const ERC20Factory = await ethers.getContractFactory("TestERC20");
    ERC20Contract = await ERC20Factory.deploy(GLOBAL_TRX_CONFIG);
    await ERC20Contract.deployed();

    // Deploy the test NFT contract
    const NFTFactory = await ethers.getContractFactory("TestNFT");
    NFTContract = await NFTFactory.deploy(GLOBAL_TRX_CONFIG);
    await NFTContract.deployed();
    feeContract = await NFTFactory.deploy(GLOBAL_TRX_CONFIG);
    await feeContract.deployed();

    // Deploy the test wrapper contract
    const wrapperFactory = await ethers.getContractFactory("TestWrapper");
    wrapperContract = await wrapperFactory.deploy(GLOBAL_TRX_CONFIG);
    await wrapperContract.deployed();

    // Deploy the Zora marketplace contracts
    const royaltyEngineFactory = await ethers.getContractFactory("TestRoyaltyEngine");
    royaltyEngineContract = await royaltyEngineFactory.deploy(GLOBAL_TRX_CONFIG);
    await royaltyEngineContract.deployed();

    const royaltyRegistryFactory = await ethers.getContractFactory("TestRoyaltyRegistry");
    royaltyRegistryContract = await royaltyRegistryFactory.deploy(GLOBAL_TRX_CONFIG);
    await royaltyRegistryContract.deployed();

    const protocolFeeSettingsFactory = await ethers.getContractFactory("TestProtocolFeeSettings");
    protocolFeeSettingsContract = await protocolFeeSettingsFactory.deploy(GLOBAL_TRX_CONFIG);
    await protocolFeeSettingsContract.deployed();

    const zoraModuleManagerFactory = await ethers.getContractFactory("TestZoraModuleManager");
    zoraModuleManagerContract = await zoraModuleManagerFactory.deploy(
      signers[0].address,
      // royaltyRegistryContract.address, // TODO: not sure yet if this contract is meant to be the "registrar"
      protocolFeeSettingsContract.address,
      GLOBAL_TRX_CONFIG
    );
    await zoraModuleManagerContract.deployed();

    const ERC20TransferHelperFactory = await ethers.getContractFactory("TestERC20TransferHelper");
    ERC20TransferHelperContract = await ERC20TransferHelperFactory.deploy(
      zoraModuleManagerContract.address,
      GLOBAL_TRX_CONFIG
    );
    await ERC20TransferHelperContract.deployed();

    const ERC721TransferHelperFactory = await ethers.getContractFactory("TestERC721TransferHelper");
    ERC721TransferHelperContract = await ERC721TransferHelperFactory.deploy(
      zoraModuleManagerContract.address,
      GLOBAL_TRX_CONFIG
    );
    await ERC721TransferHelperContract.deployed();

    const asksV1_1Factory = await ethers.getContractFactory("TestAsksV1_1");
    asksV1_1Contract = await asksV1_1Factory.deploy(
      ERC20TransferHelperContract.address,
      ERC721TransferHelperContract.address,
      royaltyEngineContract.address,
      protocolFeeSettingsContract.address,
      ERC20Contract.address,
      GLOBAL_TRX_CONFIG
    );
    await asksV1_1Contract.deployed();

    // Set up wallets
    deployer = new Wallet(wrapperContract, signers[0]);
    deployerNFT = new Wallet(NFTContract, signers[0]);
    deployerFee = new Wallet(protocolFeeSettingsContract, signers[0]);
    bob = new Wallet(wrapperContract, signers[1]);
    alice = new Wallet(wrapperContract, signers[2]);
    registrar = new Wallet(zoraModuleManagerContract, signers[0]);

    wallets = [deployer, bob, alice];

    walletsByAddress = wallets.reduce(
      (memo, wallet) => ({ ...memo, [wallet.address]: wallet }),
      {}
    );

    await Promise.all(
      wallets.map(function (wallet) {
        return wallet.setup();
      })
    );

    snapshot = await snapshotEVM(provider);
  });

  /**
   * Between each test wipe the state of the contract.
   */
  beforeEach(async function () {
    await revertEVM(provider, snapshot);
    snapshot = await snapshotEVM(provider);
  });

  // TODO: some ideas for test cases:
  // - list a non-wrapped token
  // - use all functions in Listing.sol
  // - failure paths: see why selling on the marketplace might fail
  describe.only("#setListing()", async function () {
    // No fail circumstances.
    context("fails", async function () {});

    context("succeeds", async function () {
      it("Lists the token up for sale", async function () {
        const wrappedId = await wrap(TOKENS.ONE, bob);
        
        await deployerFee.contract.init(zoraModuleManagerContract.address, zoraModuleManagerContract.address); // TODO: what is the second argument?
        await registrar.contract.registerModule(asksV1_1Contract.address);

        const trx = await deployer.contract.setListing(
          wrappedId,
          asksV1_1Contract.address,
          zoraModuleManagerContract.address,
          wrapValuation,
          bob.address
        );
      });
    });
  });
});

