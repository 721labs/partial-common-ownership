import { expect } from "chai";
import { ethers } from "hardhat";

import Wallet from "./helpers/Wallet";

import { GLOBAL_TRX_CONFIG } from "./helpers/constants";
import { taxationPeriodToSeconds } from "./helpers/utils";
import { snapshotEVM, revertEVM } from "./helpers/EVM";

// Types
import { TOKENS } from "./helpers/types";
import type { Contract } from "@ethersproject/contracts";
import type { Web3Provider } from "@ethersproject/providers";
import type { SignerWithAddress } from "@nomiclabs/hardhat-ethers/signers";
import type { BigNumber } from "ethers";

//$ Constants

const mintedTestNFTs = [TOKENS.ONE, TOKENS.TWO, TOKENS.THREE];

const testTokenURI = "i.am.a.domain.name";
const wrapperName = "Partial Common Ownership Token Wrapper";
const wrapperSymbol = "wPCO";

const taxConfig = { collectionFrequency: 90, taxRate: 50000000000 };

const TAX_NUMERATOR = ethers.BigNumber.from(taxConfig.taxRate);

const TAX_PERIOD_AS_SECONDS = taxationPeriodToSeconds(
  taxConfig.collectionFrequency
);

//$ State
let provider: Web3Provider;
let signers: Array<SignerWithAddress>;
let testNFTContract: Contract;
let wrapperContract: Contract;
let beneficiary: Wallet;
let alice: Wallet;
let bob: Wallet;
let snapshot: any;
let deployerAddress: string;

//$ Helpers

/**
 * Generates the token ID for a wrapper NFT.
 * IDs are generated by taking the first 4 bytes of hash(contract, tokenId).
 * @param contractAddress NFT Contract Address
 * @param tokenId NFT token id
 * @returns ID string
 */
function wrappedTokenId(contractAddress: string, tokenId: TOKENS): BigNumber {
  return ethers.BigNumber.from(
    ethers.utils.keccak256(
      ethers.utils.defaultAbiCoder.encode(
        ["address", "uint"],
        [contractAddress, tokenId]
      )
    )
  );
}

//$ Tests

describe("Wrapper.sol", async function () {
  before(async function () {
    //@ts-ignore
    provider = new ethers.providers.Web3Provider(web3.currentProvider);
    signers = await ethers.getSigners();

    // Deploy the test NFT contract
    const testNFTFactory = await ethers.getContractFactory("TestNFT");
    testNFTContract = await testNFTFactory.deploy(GLOBAL_TRX_CONFIG);
    await testNFTContract.deployed();

    // Deploy the test wrapper contract
    const wrapperFactory = await ethers.getContractFactory("TestWrapper");
    wrapperContract = await wrapperFactory.deploy(GLOBAL_TRX_CONFIG);
    await wrapperContract.deployed();

    // Set up wallets

    deployerAddress = signers[0].address;
    beneficiary = new Wallet(wrapperContract, signers[1]);
    alice = new Wallet(wrapperContract, signers[2]);
    bob = new Wallet(wrapperContract, signers[3]);

    snapshot = await snapshotEVM(provider);
  });

  /**
   * Between each test wipe the state of the contract.
   */
  beforeEach(async function () {
    await revertEVM(provider, snapshot);
    snapshot = await snapshotEVM(provider);
  });

  describe("TestNFT.sol", async function () {
    it("Sets up properly", async function () {
      for await (const tokenId of mintedTestNFTs) {
        expect(await testNFTContract.ownerOf(tokenId)).to.equal(
          deployerAddress
        );
      }
    });
  });

  describe("#constructor()", async function () {
    // No fail circumstances.
    context("fails", async function () {});

    context("succeeds", async function () {
      it("Assigns name and symbol to PCO contract", async function () {
        expect(await wrapperContract.name()).to.equal(
          "Partial Common Ownership NFT"
        );
        expect(await wrapperContract.symbol()).to.equal("pcoNFT");
      });
    });
  });

  describe("#wrappedTokenId()", async function () {
    // No fail circumstances.
    context("fails", async function () {});

    context("succeeds", async function () {
      it("Deterministically generates wrapped token IDs", async function () {
        for await (const tokenId of mintedTestNFTs) {
          expect(
            await wrapperContract.wrappedTokenId(
              testNFTContract.address,
              tokenId
            )
          ).to.equal(wrappedTokenId(testNFTContract.address, tokenId));
        }
      });
    });
  });

  // describe("#acquire()", async function () {
  //   context("succeeds", async function () {
  //     it(`Acquires the token succesfully`, async function () {
  //       await testNFTContract.approve(wrapperContract.address, TOKENS.ONE);

  //       expect(
  //         await wrapperContract.acquire(
  //           testNFTContract.address,
  //           beneficiary.address,
  //           TOKENS.ONE,
  //           100,
  //           TAX_NUMERATOR,
  //           taxConfig.collectionFrequency
  //         )
  //       )
  //         .to.emit(wrapperContract, "Acquire")
  //         .withArgs(wrappedTokenIds[TOKENS.ONE]);
  //       expect(
  //         await wrapperContract.ownerOf(wrappedTokenIds[TOKENS.ONE])
  //       ).to.equal(deployerAddress);
  //       expect(
  //         await wrapperContract.priceOf(wrappedTokenIds[TOKENS.ONE])
  //       ).to.equal(100);
  //       expect(
  //         await wrapperContract.beneficiaryOf(wrappedTokenIds[TOKENS.ONE])
  //       ).to.equal(beneficiary.address);
  //       expect(
  //         await wrapperContract.taxRateOf(wrappedTokenIds[TOKENS.ONE])
  //       ).to.equal(TAX_NUMERATOR);
  //       expect(
  //         await wrapperContract.taxPeriodOf(wrappedTokenIds[TOKENS.ONE])
  //       ).to.equal(TAX_PERIOD_AS_SECONDS);
  //     });
  //   });

  //   context("fails", async function () {
  //     it(`Cannot acquire the token if not approved`, async function () {
  //       try {
  //         await wrapperContract.acquire(
  //           testNFTContract.address,
  //           beneficiary.address,
  //           TOKENS.ONE,
  //           100,
  //           TAX_NUMERATOR,
  //           taxConfig.collectionFrequency
  //         );
  //       } catch (error) {
  //         expect(error.message).to.equal(
  //           "VM Exception while processing transaction: reverted with reason string 'ERC721: transfer caller is not owner nor approved'"
  //         );
  //       }
  //     });
  //   });
  // });

  // describe("#tokenURI()", async function () {
  //   context("succeeds", async function () {
  //     it(`Can get the tokenURI via the wrapper succesfully`, async function () {
  //       await testNFTContract.approve(wrapperContract.address, TOKENS.ONE);

  //       await wrapperContract.acquire(
  //         testNFTContract.address,
  //         beneficiary.address,
  //         TOKENS.ONE,
  //         100,
  //         TAX_NUMERATOR,
  //         taxConfig.collectionFrequency
  //       );

  //       expect(
  //         await wrapperContract.tokenURI(wrappedTokenIds[TOKENS.ONE])
  //       ).to.equal(testTokenURI);
  //     });
  //   });
  // });
});
